#!/usr/bin/env python3
"""백엔드 Few-shot 예시 F~J 정확도 테스트"""
import json
import urllib.request

API_URL = "http://127.0.0.1:8000/api/kpi/analyze/backend"

EXAMPLES = {
    "F (균형형·실무형)": {
        "text": """웹 기반 서비스 개발 프로젝트에서 백엔드 개발을 담당하며 API 구현부터 운영 환경 개선까지 경험했습니다. 서비스 초기에는 기능 구현에 집중해 REST API를 설계하고, ORM을 활용해 데이터베이스 모델을 구성했습니다. 사용자 조회와 목록 제공 기능의 응답 속도가 느려지는 문제가 발생해, 로그를 통해 요청 패턴을 분석하고 조회 빈도가 높은 컬럼을 기준으로 인덱스를 추가해 성능을 개선했습니다. 서비스를 클라우드 환경에 배포해 운영하는 과정에서 배포 자동화의 필요성을 느껴, 간단한 CI/CD 파이프라인을 구성해 코드 변경 시 서버에 자동 반영되도록 개선했습니다. 또한 운영 중 발생하는 오류를 빠르게 확인하기 위해 애플리케이션 로그를 정리하고, 기본적인 모니터링 설정을 적용해 장애 원인을 파악하는 시간을 줄였습니다. 아키텍처 측면에서는 기존 단일 서버 구조를 유지하되, 향후 트래픽 증가를 고려해 서비스와 배치 작업을 분리하는 방향으로 구조를 정리했습니다. 대규모 구조 전환을 직접 주도하지는 않았지만, 확장 가능성을 고려한 설계 기준을 팀 내에서 공유하며 개발을 진행했습니다. 개발 과정에서는 기획자 및 프론트엔드 개발자와 협업하며 API 명세를 문서로 정리해 공유했고, 변경 사항이 발생할 때마다 이를 업데이트해 혼선을 줄였습니다. 이 경험을 통해 저는 단순 기능 구현을 넘어, 서비스 운영과 협업을 고려한 백엔드 개발의 중요성을 인식하게 되었습니다.""",
        "expected": {1: 76, 2: 68, 3: 68, 4: 65, 5: 72, 6: 78, 7: 42, 8: 55, 9: 80, 10: 70}
    },
    "G (데이터·성능형)": {
        "text": """대규모 데이터 처리가 필요한 웹 서비스에서 백엔드 개발을 담당하며 데이터 흐름과 처리 구조 개선에 집중했습니다. 초기 구현 단계에서는 단순 CRUD 중심으로 API를 구성했으나, 서비스 이용이 늘어나면서 특정 통계 API에서 응답 지연과 서버 부하가 반복적으로 발생했습니다. 이를 해결하기 위해 요청 로그와 쿼리 실행 시간을 기준으로 병목 구간을 분석했고, 단일 요청에서 모든 데이터를 계산하던 구조가 문제임을 파악했습니다. 이에 실시간 계산이 필요하지 않은 데이터는 배치 작업으로 분리하고, 집계 결과를 별도의 테이블에 저장해 API에서는 계산된 값을 조회하는 방식으로 구조를 변경했습니다. 이 과정에서 기존 API 응답 형식을 유지하면서 내부 처리 구조만 개선해 프론트엔드 변경 없이 성능을 개선할 수 있도록 설계했습니다. 해당 개선 이후 응답 시간이 크게 단축되었고, 피크 시간대에도 서버 부하가 안정적으로 유지되었습니다. 서비스는 클라우드 환경에서 운영되었으며, 배포 과정에서 환경별 설정 차이로 발생하던 오류를 줄이기 위해 설정 값을 환경 변수로 분리해 관리했습니다. 또한 장애 발생 시 원인을 빠르게 파악할 수 있도록 주요 처리 단계에 로그를 추가하고, 운영 중 발생한 이슈를 정리해 재발 방지 기준으로 공유했습니다. 개발 과정에서는 기획 및 프론트엔드 개발자와 협업하며 데이터 정의와 API 변경 사항을 문서로 정리했고, 성능 개선 방향에 대한 판단 근거를 공유하며 작업을 진행했습니다.""",
        "expected": {1: 76, 2: 68, 3: 80, 4: 75, 5: 70, 6: 85, 7: 42, 8: 45, 9: 78, 10: 70}
    },
    "H (보안·인증형)": {
        "text": """금융 데이터가 포함된 웹 서비스 개발 프로젝트에서 백엔드 개발을 담당하며, 인증과 접근 제어 중심의 보안 구조 설계에 집중했습니다. 서비스 특성상 사용자별 접근 권한과 데이터 노출 범위를 명확히 구분하는 것이 중요했기 때문에, 초기 단계부터 인증·권한 흐름을 구조적으로 설계했습니다. OAuth 기반 로그인 흐름을 도입하고, 토큰 발급과 만료 정책을 명확히 정의해 세션 관리 이슈를 최소화했습니다. API 접근 시에는 사용자 역할에 따라 권한을 분리하고, 공통 미들웨어를 통해 인증 여부와 권한 검증이 일관되게 적용되도록 구성했습니다. 또한 민감한 요청과 응답에 대해서는 로깅 정책을 별도로 설정해, 이상 접근이나 오류 발생 시 추적이 가능하도록 했습니다. 비밀번호 및 토큰과 관련된 정보는 암호화해 저장하고, 환경 변수와 설정 파일을 분리해 운영 환경에서의 노출 위험을 줄였습니다. 기능 구현 측면에서는 기존 설계에 따라 REST API를 구현하고 데이터베이스와 연동했으며, 성능 최적화나 아키텍처 구조 변경보다는 보안 요구사항을 충족하는 데 우선순위를 두고 개발을 진행했습니다. 테스트 코드나 자동화된 배포 환경까지는 직접 구축하지 않았지만, 인증 로직 변경 시에는 기존 기능에 영향을 주지 않도록 검증 절차를 거쳤습니다.""",
        "expected": {1: 62, 2: 65, 3: 60, 4: 55, 5: 50, 6: 48, 7: 85, 8: 42, 9: 50, 10: 42}
    },
    "I (품질·협업형)": {
        "text": """팀 프로젝트에서 백엔드 개발을 맡아 기능 구현뿐 아니라 테스트와 코드 품질 체계를 정비하는 역할을 수행했습니다. 초기에는 빠르게 기능을 붙이느라 API 동작은 되었지만, 요구사항 변경이 생길 때마다 기존 기능에서 회귀 오류가 발생해 수정 비용이 커지는 문제가 반복되었습니다. 이를 해결하기 위해 '변경이 잦은 구간을 안전하게 만드는 것'을 목표로 테스트 전략을 재정의했습니다. 핵심 도메인 로직을 서비스 계층으로 분리하고, 주요 유스케이스 단위로 단위 테스트를 작성해 입력·예외·경계 조건을 검증했습니다. 또한 API 레벨에서는 통합 테스트를 구성해 인증이 필요한 요청, 실패 응답, 정상 응답이 규약대로 유지되는지 확인했습니다. 테스트 실행 시간이 늘어나지 않도록 픽스처를 정리하고, 외부 의존성은 목 처리해 테스트 안정성을 확보했습니다. 코드 품질 측면에서는 린트·포맷 규칙과 정적 분석 기준을 프로젝트에 적용하고, PR 템플릿과 리뷰 체크리스트를 도입해 팀 내 변경사항이 일정 수준의 품질 기준을 통과하도록 했습니다. 주요 설계 결정과 API 변경 이력은 문서로 남겨 이후 합류한 팀원이 맥락을 빠르게 이해할 수 있게 했습니다.""",
        "expected": {1: 60, 2: 68, 3: 45, 4: 62, 5: 40, 6: 70, 7: 40, 8: 80, 9: 82, 10: 40}
    },
    "J (학습·입문형)": {
        "text": """백엔드 개발을 처음 접하며 웹 서비스의 서버 기능을 구현하는 프로젝트에 참여했습니다. Spring Boot 기반으로 컨트롤러와 서비스 구조를 이해하고, 요청에 따라 데이터를 저장·조회하는 API를 구현했습니다. 회원 정보와 게시글 데이터를 데이터베이스에 연동해 기본적인 CRUD 기능을 완성했으며, 로컬 환경에서 서버를 실행해 정상적으로 동작하는 것을 확인했습니다. 개발 과정에서는 API 요청과 응답 흐름, 컨트롤러와 서비스 계층의 역할 분리를 중심으로 학습하며 구현을 진행했습니다. 오류가 발생했을 때는 로그 메시지를 확인하거나 관련 문서를 찾아 문제를 해결했고, 이를 통해 서버 개발의 기본적인 디버깅 과정을 익혔습니다. 데이터베이스 설계는 단순한 테이블 구조를 기준으로 진행했으며, 성능이나 확장성을 고려한 구조 변경까지는 진행하지 않았습니다. 배포 환경이나 운영을 직접 경험하기보다는, 주어진 개발 환경 내에서 기능 구현과 코드 이해에 집중했습니다. 테스트 코드나 모니터링 설정은 별도로 작성하지 않았지만, 기능 단위로 직접 요청을 보내며 동작 여부를 확인하는 방식으로 검증했습니다. 팀 프로젝트를 통해 백엔드 개발의 전체 흐름을 경험하며, 이후 실제 서비스 환경에서 필요한 아키텍처 설계와 운영 역량의 중요성을 인식하게 되었습니다.""",
        "expected": {1: 48, 2: 56, 3: 50, 4: 42, 5: 40, 6: 40, 7: 40, 8: 42, 9: 42, 10: 40}
    }
}


def test_example(name, text, expected):
    req = urllib.request.Request(
        API_URL,
        data=json.dumps({"resume_text": text}).encode("utf-8"),
        headers={"Content-Type": "application/json"},
        method="POST",
    )
    try:
        with urllib.request.urlopen(req, timeout=120) as res:
            data = json.loads(res.read().decode("utf-8"))
    except Exception as e:
        print(f"  API 호출 실패: {e}")
        return 0
    
    scores_list = data.get("scores", [])
    actual = {item["kpi_id"]: item["score"] for item in scores_list}
    
    print(f"\n예시 {name}")
    print("-" * 50)
    diffs = []
    for kpi_id in range(1, 11):
        exp = expected.get(kpi_id, 0)
        act = actual.get(kpi_id, 0)
        diff = abs(exp - act)
        diffs.append(diff)
        status = "OK" if diff <= 5 else "X"
        print(f"  KPI {kpi_id:2d}: 예상={exp:2d}, 실제={act:2d}, 차이={diff:2d} [{status}]")
    
    accuracy = sum(1 for d in diffs if d <= 5) / len(diffs) * 100
    print(f"  정확도: {accuracy:.0f}%")
    return accuracy


def main():
    print("=" * 50)
    print("백엔드 Few-shot 예시 F~J 정확도 테스트")
    print("=" * 50)
    
    results = {}
    for name, data in EXAMPLES.items():
        accuracy = test_example(name, data["text"], data["expected"])
        results[name] = accuracy
    
    print("\n" + "=" * 50)
    print("종합 결과")
    print("=" * 50)
    for name, acc in results.items():
        status = "✓" if acc >= 80 else "✗"
        print(f"  {name}: {acc:.0f}% {status}")
    
    avg = sum(results.values()) / len(results)
    print(f"\n  평균 정확도: {avg:.0f}%")


if __name__ == "__main__":
    main()
