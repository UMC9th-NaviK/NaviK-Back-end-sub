"""
LLM 기반 프론트엔드 KPI 직접 평가 모듈.

Few-shot Learning을 활용하여 이력서 텍스트에서 
프론트엔드 개발자 KPI 10개에 대한 점수를 직접 산출.
"""
from typing import Dict
from openai import OpenAI
import json

from app.core.config import settings


# KPI 정의 및 평가 기준
KPI_DEFINITIONS = """
## FE KPI 10개 및 평가 기준

아래 예시는 **"기준표"** 역할을 함 → 지원자 경험이 **이 중 어디와 가장 비슷한지만 판단**

## 공통 원칙 (중요)
- 모든 예시는 **이력서 문단 그대로 들어가도 자연스러운 서술**
- **도구 이름보다 판단/행동/결과 중심**
- "학습/경험"만 있으면 **하**
- "운영 중 문제 → 구조/전략 변경"이 있으면 **상**

## 점수 범위
- **상**: 75~90점 (강한 상=88~90, 보통 상=80~87, 약한 상=75~79)
- **중**: 55~70점 (강한 중=67~70, 보통 중=60~66, 약한 중=55~59)
- **하**: 40~50점 (언급 있음=48~50, 약간 언급=44~47, 전혀 없음=40~43)

## 평가 원칙
- 명시적으로 언급되지 않은 KPI는 "하(40~45)" 처리
- 도구/기술 이름만 나열하면 "중(55~65)" 상한
- "문제→판단→해결→결과" 흐름이 있으면 "상(80~90)" 가능
- 학습/경험만 언급하면 "하(45~50)"
- 같은 레벨 내에서도 근거의 강도에 따라 세부 점수 차등

---

## KPI 요약표 (빠른 참조용)

| # | KPI | 상(75~90) | 중(55~70) | 하(40~50) |
|---|-----|-----------|-----------|-----------|
| 1 | 웹 기본기(HTML/CSS/JS/TS) | DOM 조작, 반응형, 비동기 처리 등 기본기 탄탄, 실전 활용 | 기본 문법 이해, 간단한 기능 구현 | 튜토리얼/예제 수준 학습 |
| 2 | 프레임워크 숙련도(React/Vue/TS) | 컴포넌트 구조, SSR/CSR, Hooks 등 깊이 있게 이해 | 기본 컴포넌트 작성, 상태 관리 사용 | 예제 따라하기 수준 |
| 3 | 상태관리·컴포넌트 아키텍처 | 재사용·확장 고려한 컴포넌트 설계, 상태 분리 전략 | 기본적인 컴포넌트 분리 | 단일 컴포넌트 구조 |
| 4 | 웹 성능 최적화(LCP·CLS) | 지표 기반 병목 분석, 로딩/인터랙션 경험 개선, 수치적 결과 | 성능 이슈 인지하고 일부 개선 | 성능 고려 없음 |
| 5 | API 연동·비동기 처리 | 에러 핸들링, 로딩 처리, 캐싱 전략까지 고려 | 기본 API 호출 구현 | API 연동 경험 없음 |
| 6 | 반응형·크로스 브라우징 대응 | 다양한 디바이스/브라우저 환경에서 일관된 동작 | 기본 반응형 구현 | 반응형/크로스브라우징 고려 없음 |
| 7 | 테스트 코드·품질 관리 | 유닛/통합 테스트, 린트, 타입 안정성 유지 | 일부 테스트 또는 간단한 린트 | 테스트/품질 관리 없음 |
| 8 | Git·PR·협업 프로세스 이해 | 코드 리뷰, PR 규칙, Gitflow 등 협업 프로세스 이해 | 기본 Git 사용 | Git/협업 경험 없음 |
| 9 | 사용자 중심 UI 개발(UX 연계) | 디자인 의도 이해, 사용성/인터랙션 고려한 구현 | 디자인 시안 따라 구현 | 사용성 고려 없음 |
| 10 | 빌드·도구 환경(Vite/Webpack) | 번들링 이해, 프로젝트 규모에 맞는 도구 선택·관리 | 기본 빌드 도구 사용 | 빌드 도구 경험 없음 |

---

## KPI별 상세 예시

## 1️⃣ 웹 기본기 (HTML/CSS/JS/TS)

### 🔼 상
DOM 구조와 렌더링 흐름을 고려해 마크업을 설계하고, 비동기 처리 과정에서 발생하는 상태 변화와 이벤트 흐름을 안정적으로 제어했습니다. 타입을 활용해 런타임 오류를 줄이고, 웹 동작 원리를 이해한 구현을 수행했습니다.

### 🔽 중
HTML/CSS/JavaScript를 사용해 화면과 기능을 구현하고, 비동기 요청을 처리했습니다.

### 🔻 하
예제와 자료를 참고해 화면과 기능을 구현했습니다.

---

## 2️⃣ 프레임워크 숙련도 (React/Vue/TS)

### 🔼 상
컴포넌트 책임을 분리해 구조를 설계하고, 상태와 사이드 이펙트를 적절히 관리했습니다. 프레임워크 특성을 고려해 CSR/SSR 환경에서의 동작 차이를 이해하고 구현했습니다.

### 🔽 중
프레임워크를 사용해 컴포넌트 기반으로 화면을 구현했습니다.

### 🔻 하
프레임워크 문법을 따라 기능을 구현했습니다.

---

## 3️⃣ 상태관리·컴포넌트 아키텍처

### 🔼 상
전역 상태와 로컬 상태를 역할에 맞게 분리하고, 재사용 가능한 컴포넌트 구조를 설계해 확장성과 유지보수성을 확보했습니다.

### 🔽 중
상태 관리를 적용해 컴포넌트 간 데이터 전달을 처리했습니다.

### 🔻 하
props를 통해 필요한 데이터를 전달했습니다.

---

## 4️⃣ 웹 성능 최적화 (LCP·CLS)

### 🔼 상
Lighthouse 지표를 기준으로 성능 병목을 분석하고, 이미지 최적화·코드 스플리팅 등을 적용해 LCP와 CLS를 개선했습니다.

### 🔽 중
성능 이슈를 인지하고 일부 최적화를 적용했습니다.

### 🔻 하
성능 지표를 고려하지 않고 구현했습니다.

---

## 5️⃣ API 연동 & 비동기 처리

### 🔼 상
API 호출 흐름을 설계하고, 로딩·에러·캐싱 상태를 분리해 사용자 경험을 안정적으로 구성했습니다.

### 🔽 중
API를 호출해 데이터를 화면에 표시하고 에러를 처리했습니다.

### 🔻 하
API를 호출해 데이터를 받아왔습니다.

---

## 6️⃣ 반응형·크로스 브라우징 대응

### 🔼 상
다양한 디바이스와 브라우저 환경을 고려해 반응형 레이아웃을 설계하고, 환경별 이슈를 사전에 대응했습니다.

### 🔽 중
반응형 레이아웃을 적용했습니다.

### 🔻 하
특정 해상도 기준으로만 구현했습니다.

---

## 7️⃣ 테스트 코드·품질 관리

### 🔼 상
주요 로직에 대해 테스트 코드를 작성하고, 린트·타입 체크를 통해 코드 품질을 지속적으로 관리했습니다.

### 🔽 중
일부 테스트나 린트 규칙을 적용했습니다.

### 🔻 하
테스트나 품질 관리 도구를 사용하지 않았습니다.

---

## 8️⃣ Git·PR·협업 프로세스 이해

### 🔼 상
PR 기반 협업 과정에서 코드 리뷰를 주고받으며, 팀 규칙에 맞춰 변경 이력을 관리했습니다.

### 🔽 중
Git을 사용해 협업하며 PR을 경험했습니다.

### 🔻 하
개인 브랜치에서만 작업했습니다.

---

## 9️⃣ 사용자 중심 UI 개발 (UX 연계)

### 🔼 상
디자인 의도를 이해하고, 실제 사용 흐름을 고려해 인터랙션과 UI를 개선했습니다. 사용자 피드백을 반영해 사용성을 개선했습니다.

### 🔽 중
디자인 시안을 기준으로 UI를 구현했습니다.

### 🔻 하
주어진 화면을 그대로 구현했습니다.

---

## 🔟 빌드·도구 환경 (Vite/Webpack)

### 🔼 상
프로젝트 규모에 맞춰 빌드 도구를 설정하고, 번들링 전략을 조정해 개발·배포 효율을 개선했습니다.

### 🔽 중
기존 설정을 사용해 프로젝트를 구성했습니다.

### 🔻 하
빌드 도구 설정을 다뤄본 적이 없습니다.
"""

# Few-shot 예시 (대표적인 2개)
FEW_SHOT_EXAMPLES = """
## 평가 예시

### 예시 A (실시간 서비스형 프론트엔드 - 자소서/이력서 버전)
입력:
"프론트엔드 개발자는 단순히 화면을 구현하는 역할을 넘어, 사용자 행동이 실시간으로 반영되는 구조를 안정적으로 설계하고 운영 환경까지 고려한 개발을 수행해야 한다고 생각합니다. 저는 웹 서비스 개발 과정에서 UI 구현, 비동기 데이터 처리, 실시간 알림, 배포 환경 이슈 대응까지 경험하며 이러한 역량을 쌓아왔습니다. 추천 기반 소셜 플랫폼 개발에 참여해 회원가입과 홈 화면의 주요 기능을 구현했습니다. 추천 카드 UI를 중심으로 사용자 정보를 탐색하고, 상세 정보 확인 후 제안을 전송하는 흐름을 구성했으며, API 연동을 통해 사용자 행동이 즉시 화면에 반영되도록 처리했습니다. 특히 Service Worker 기반 푸시 알림 기능을 구현해, 특정 이벤트 발생 시 브라우저 알림이 실시간으로 표시되는 구조를 설계했습니다. 이 과정에서 프론트엔드와 서버 간 비동기 요청 흐름과 상태 변화를 직접 다루며 실시간 서비스 구조에 대한 이해를 높일 수 있었습니다. 개발 과정에서는 다양한 문제 상황을 구조적으로 해결하는 경험을 했습니다. 반응형 구현 초기에는 특정 해상도 기준으로만 화면이 맞춰져 PC 환경에서 레이아웃이 깨지는 문제가 발생했습니다. 단순한 위치 속성 조정으로는 한계가 있다고 판단해 레이아웃 구조를 전면적으로 재설계했고, 공통 Layout 컴포넌트를 분리해 화면 수정 시 전체 UI에 일관되게 반영되도록 개선했습니다. 이를 통해 반응형 대응과 유지보수성을 동시에 확보할 수 있었습니다. 또한 UI 구현 과정에서 기능 범위가 과도하게 확장되며 일정 지연이 발생한 경험을 통해, 모든 기능을 한 번에 구현하기보다 핵심 사용자 흐름을 우선 완성하는 것이 중요하다는 점을 인식하게 되었습니다. 이후에는 우선순위를 기준으로 기능을 단계적으로 구현하며 개발 효율을 개선했습니다. 배포 이후에는 푸시 알림이 정상 동작하지 않는 문제를 발견했고, Service Worker 설정 충돌이 원인임을 분석해 등록 시점과 빌드 설정을 조정함으로써 문제를 해결했습니다. 이러한 경험을 통해 저는 프론트엔드 개발에서 UI 표현뿐 아니라 비동기 처리, 사용자 경험, 배포 환경 안정성까지 함께 고려하는 사고방식을 갖추게 되었습니다. 앞으로도 웹의 동작 원리를 이해하고, 사용자에게 안정적으로 동작하는 화면과 흐름을 제공할 수 있는 프론트엔드 개발자로 기여하고자 합니다."

출력:
{"1": 65, "2": 65, "3": 65, "4": 45, "5": 85, "6": 85, "7": 45, "8": 45, "9": 85, "10": 65}

근거:
- KPI 1(65): 반응형 레이아웃 재설계 언급은 있으나 DOM·이벤트·CSS 구조·JS 처리에 대한 구체 증거 감소 → 보통 중
- KPI 2(65): React·TS 직접 언급 없음, 컴포넌트 구조, 훅, 상태 흐름 기술이 빠짐 → 보통 중
- KPI 3(65): 공통 Layout 컴포넌트 분리는 유지되나 상태 구조, 재사용 전략, 아키텍처 근거는 약함 → 보통 중
- KPI 4(45): 성능 지표, 로딩, CLS/LCP, 렌더링 언급 없음 → 하
- KPI 5(85): API 연동, 비동기 흐름, 실시간 반영, Service Worker → 강한 상
- KPI 6(85): 반응형 구조 재설계, PC·모바일 문제 해결 → 강한 상
- KPI 7(45): 테스트·품질 언급 없음 → 하
- KPI 8(45): 협업 도구·PR·리뷰 언급 전혀 없음 → 하
- KPI 9(85): 사용자 흐름, 핵심 기능 우선순위, UX 기반 구조 조정 → 강한 상
- KPI 10(65): 빌드 설정 조정 언급은 있으나 Vite/PWA/환경 구조 증거는 빠짐 → 보통 중

### 예시 B (실무형 FE - 중)
입력:
"웹 서비스 개발 프로젝트에서 프론트엔드 개발을 맡아 주요 화면 UI와 API 연동을 구현했습니다. 디자인 시안을 바탕으로 홈 화면과 상세 페이지를 구성하고, 서버에서 전달받은 데이터를 목록과 상세 화면에 표시하는 기능을 담당했습니다. 사용자가 버튼을 클릭하면 API 요청이 발생하고, 응답에 따라 화면이 갱신되도록 비동기 처리를 구현했습니다. 모바일과 데스크톱 환경에서 모두 사용할 수 있도록 미디어 쿼리와 기본적인 반응형 스타일을 적용했으며, 개발 중 발생한 오류는 콘솔 로그와 네트워크 요청을 확인하며 수정했습니다. 다만 컴포넌트 구조와 상태 관리 방식은 기존 프로젝트 설정을 따랐고, 전역 상태 설계나 아키텍처 구조를 새로 정의하지는 않았습니다. 또한 빌드 도구나 배포 환경 설정에는 직접 관여하지 않았으며, 주어진 환경에서 기능 구현과 일정 준수에 집중했습니다. 이 경험을 통해 프론트엔드가 서버와 연동되어 동작하는 기본 구조와 실무 환경에서의 역할 수행 방식을 익힐 수 있었습니다."

출력:
{"1": 65, "2": 65, "3": 45, "4": 45, "5": 65, "6": 65, "7": 45, "8": 45, "9": 65, "10": 45}

근거:
- KPI 1(65): 미디어 쿼리, UI 구성, 이벤트 → API → 화면 반영, 기본적인 DOM·레이아웃·JS 흐름 충분 → 보통 중
- KPI 2(65): 컴포넌트 기반 UI, 상태 사용은 있으나 훅 구조, 컴포넌트 설계 역량 증거 없음 → 보통 중
- KPI 3(45): "기존 프로젝트 설정을 따름", 전역 상태·아키텍처 설계 없음 → 하
- KPI 4(45): LCP, CLS, 로딩, 번들, 최적화 언급 없음 → 하
- KPI 5(65): 요청 → 응답 → 화면 갱신, 비동기 흐름 구현 → 보통 중
- KPI 6(65): 모바일·데스크톱 대응, 기본 반응형 적용 → 보통 중
- KPI 7(45): 테스트, 린트, 타입 안정성 언급 없음 → 하
- KPI 8(45): 협업 도구, PR, 리뷰, Gitflow 언급 없음 → 하
- KPI 9(65): 홈/상세 흐름, 사용자 행동에 따른 UI 반영은 있으나 UX 전략·개선 근거 부족 → 보통 중
- KPI 10(45): "관여하지 않았다" 명시 → 하

### 예시 C (학습형 FE - 하)
입력:
"프론트엔드 개발을 처음 접하며 React와 JavaScript를 사용해 간단한 웹 애플리케이션을 구현했습니다. 강의 자료와 예제 코드를 참고해 기본적인 컴포넌트를 만들고, 버튼 클릭 시 API를 호출해 데이터를 받아와 화면에 표시하는 기능을 구현했습니다. 상태 관리와 이벤트 처리 방식 등 프레임워크의 기본 개념을 익히는 데 집중했으며, 프로젝트는 로컬 개발 환경에서 실행했습니다. 반응형 디자인이나 성능 최적화, 빌드 설정과 같은 부분은 별도로 고려하지 않았고, 오류가 발생하면 검색을 통해 해결 방법을 찾아 적용하는 방식으로 진행했습니다. 실서비스 배포나 사용자 환경을 고려한 구조 설계 경험은 없었지만, 이 과정을 통해 프론트엔드 개발의 기본 흐름과 화면과 데이터가 연결되는 구조를 이해할 수 있었습니다. 이후 더 복잡한 프로젝트에서 구조적 설계와 운영 환경을 경험할 필요성을 느끼게 되었습니다."

출력:
{"1": 45, "2": 45, "3": 45, "4": 45, "5": 65, "6": 45, "7": 45, "8": 45, "9": 45, "10": 45}

근거:
- KPI 1(45): 튜토리얼·예제 기반, DOM, 레이아웃, 반응형, JS 구조 증거 없음 → 하
- KPI 2(45): React 사용, 기본 컴포넌트·상태는 있으나 실무 구조·훅·아키텍처 증거 없음 → 하
- KPI 3(45): 기본 상태만, 구조 설계 전혀 없음 → 하
- KPI 4(45): 최적화, 로딩, LCP/CLS 언급 없음 → 하
- KPI 5(65): API 호출, 화면 반영, 최소한의 비동기 경험은 있음 → 보통 중
- KPI 6(45): "고려하지 않았다" 명시 → 하
- KPI 7(45): 테스트, 타입, 린트 전혀 없음 → 하
- KPI 8(45): 개인 학습, 협업 구조 없음 → 하
- KPI 9(45): UX 개선, 사용자 흐름, 사용성 언급 없음 → 하
- KPI 10(45): 로컬 실행만, 빌드·배포·환경 없음 → 하

### 예시 D (UX·UI 강점형 FE - 중상)
입력:
"프론트엔드 개발자로 참여해 사용자 흐름과 화면 구조를 중심으로 UI를 구현했습니다. 단순히 디자인 시안을 그대로 옮기는 방식이 아니라, 사용자가 어떤 순서로 정보를 인지하고 행동하는지를 기준으로 화면 구성을 재정리했습니다. 복잡했던 입력 화면을 단계별로 나누고 불필요한 요소를 제거해 사용 흐름을 단순화했으며, 사용자가 중간에 이탈하던 구간을 분석해 버튼 배치와 안내 문구를 수정했습니다. 모바일과 데스크톱 환경에서 사용성이 달라지는 문제를 해결하기 위해 레이아웃과 인터랙션을 조정하고, 터치와 클릭 환경에 맞게 UI를 개선했습니다. 사용자 피드백을 반영해 화면 전환 방식과 시각적 강조 요소를 반복적으로 수정하며 사용성을 높였습니다. 다만 API 연동과 비동기 처리 로직은 기존 구조를 그대로 활용했고, 전역 상태 관리나 빌드 설정, 배포 환경 문제에는 깊게 관여하지 않았습니다. 이 경험을 통해 프론트엔드에서 사용자 경험을 설계하고 UI로 구현하는 역량이 서비스 완성도에 큰 영향을 준다는 점을 체감했습니다."

출력:
{"1": 85, "2": 65, "3": 45, "4": 45, "5": 45, "6": 85, "7": 45, "8": 45, "9": 85, "10": 45}

근거:
- KPI 1(85): 레이아웃, 인터랙션, 터치·클릭 환경 차이 대응, 화면·이벤트·레이아웃 이해 높음 → 강한 상
- KPI 2(65): 컴포넌트 기반 UI 암시는 있으나 React/Vue, 상태 구조 증거 없음 → 보통 중
- KPI 3(45): "기존 구조 활용", 전역 상태·아키텍처 설계 없음 → 하
- KPI 4(45): 로딩, 렌더링, 성능 지표 언급 없음 → 하
- KPI 5(45): "기존 구조 활용", 직접 설계·처리 증거 없음 → 하
- KPI 6(85): 모바일·데스크톱, 터치·클릭 환경 차이 대응 → 강한 상
- KPI 7(45): 테스트, 타입, 린트 없음 → 하
- KPI 8(45): 협업, 리뷰, 문서 언급 없음 → 하
- KPI 9(85): 이탈 구간 분석, 버튼·문구·전환 반복 개선, UX 근거 명확 → 강한 상
- KPI 10(45): 빌드·배포·환경 관여 안 함 → 하

### 예시 E (성능·도구 중심 FE - 중상)
입력:
"웹 서비스의 초기 로딩 속도가 느리고 번들 크기가 커지면서 사용자 이탈이 발생해 프론트엔드 성능 개선 작업을 담당했습니다. Lighthouse와 네트워크 탭을 활용해 LCP와 주요 리소스의 로딩 시간을 분석하고, 병목이 되는 스크립트와 이미지 자산을 식별했습니다. 이를 바탕으로 코드 스플리팅과 지연 로딩을 적용하고, 이미지 포맷과 크기를 최적화해 초기 렌더링 속도를 개선했습니다. 또한 Vite 기반 빌드 설정을 조정해 불필요한 번들 포함을 줄이고, 캐시 전략과 환경 변수 구성을 정리해 개발·배포 환경의 안정성을 높였습니다. 배포 과정에서 발생하던 경로 오류와 캐시 충돌 문제도 빌드 산출물 구조를 재정리해 해결했습니다. 다만 UI 구조나 사용자 흐름 설계에는 크게 관여하지 않았고, 디자인과 컴포넌트 구성은 기존 시안을 따랐습니다. 이 경험을 통해 프론트엔드에서 성능과 도구 환경이 사용자 경험과 서비스 안정성에 직접적인 영향을 준다는 점을 인식하게 되었습니다."

출력:
{"1": 65, "2": 65, "3": 45, "4": 85, "5": 45, "6": 45, "7": 45, "8": 45, "9": 45, "10": 85}

근거:
- KPI 1(65): 렌더링·리소스·로딩 이해는 있으나 DOM·레이아웃·이벤트 증거 없음 → 보통 중
- KPI 2(65): 코드 스플리팅, 번들 관리는 있으나 React/Vue 훅·구조 증거 없음 → 보통 중
- KPI 3(45): 상태 구조·컴포넌트 설계 언급 없음 → 하
- KPI 4(85): Lighthouse, LCP, 코드 스플리팅, 이미지 최적화 → 강한 상
- KPI 5(45): API, 요청, 실시간, 상태 흐름 언급 없음 → 하
- KPI 6(45): 모바일·데스크톱, 반응형 언급 없음 → 하
- KPI 7(45): 테스트, 타입, 린트 없음 → 하
- KPI 8(45): 협업, PR, 리뷰 없음 → 하
- KPI 9(45): UI/UX 개선·흐름 관여 안 함 명시 → 하
- KPI 10(85): Vite, 빌드 설정, 캐시, 배포 산출물 구조, 환경 변수 → 강한 상

### 예시 F (프론트엔드 아키텍처·상태 설계형 - 상)
입력:
"대규모 기능 확장이 예정된 웹 서비스를 개발하며 프론트엔드 구조와 상태 관리 아키텍처를 설계하는 역할을 맡았습니다. 초기에는 기능 추가가 반복되면서 컴포넌트 간 의존성이 커지고, 특정 상태 변경이 여러 화면에 영향을 주는 문제가 발생했습니다. 이를 해결하기 위해 화면 단위가 아니라 도메인 기준으로 상태를 재분리하고, 공통 레이아웃과 기능 컴포넌트를 계층 구조로 재구성했습니다. 전역 상태와 서버 상태를 분리해 관리하고, 각 화면에서는 필요한 데이터만 구독하도록 구조를 설계해 불필요한 리렌더링과 사이드 이펙트를 줄였습니다. 또한 공통 UI 패턴과 인터랙션을 컴포넌트 라이브러리 형태로 정리해, 신규 기능이 추가될 때 기존 화면에 영향을 주지 않고 확장할 수 있는 구조를 만들었습니다. API 연동 흐름 역시 요청·로딩·에러 상태를 일관되게 처리할 수 있도록 공통 훅과 유틸리티로 추상화했고, 이를 통해 기능별 구현 편차를 줄였습니다. 이러한 구조 개선으로 기능 추가 시 발생하던 버그와 수정 범위를 크게 줄였으며, 팀 내 다른 개발자들도 동일한 패턴으로 안정적으로 화면을 확장할 수 있게 되었습니다. 이 경험을 통해 저는 프론트엔드에서 단순히 화면을 만드는 것을 넘어, 서비스 규모와 변화 속도를 고려한 구조와 상태 설계가 장기적인 개발 효율과 품질을 좌우한다는 것을 체감했습니다."

출력:
{"1": 85, "2": 85, "3": 85, "4": 65, "5": 85, "6": 45, "7": 45, "8": 65, "9": 65, "10": 45}

근거:
- KPI 1(85): 리렌더링, 사이드 이펙트, 화면 단위 vs 도메인 단위, DOM·렌더링·상태 흐름 이해 깊음 → 강한 상
- KPI 2(85): 훅 추상화, 상태 분리, 컴포넌트 구조화, React/Vue 고급 사용 패턴 → 강한 상
- KPI 3(85): 도메인 기반 상태, 전역/서버 상태 분리, 컴포넌트 계층 구조 → 강한 상
- KPI 4(65): 리렌더링 감소, 사이드 이펙트 감소는 있으나 LCP/번들/네트워크 수준은 아님 → 보통 중
- KPI 5(85): 요청·로딩·에러 상태, 공통 훅, 일관된 비동기 흐름 → 강한 상
- KPI 6(45): 모바일·레이아웃·디바이스 언급 없음 → 하
- KPI 7(45): 테스트, 타입, 린트 없음 → 하
- KPI 8(65): 팀 내 확장 가능 구조, 협업 암시는 있으나 명시적 PR/ADR은 없음 → 보통 중
- KPI 9(65): 직접 UX 설계 증거는 없으나 구조 안정성이 UX에 기여한 정도 → 보통 중
- KPI 10(45): 빌드, 배포, 환경 설정 없음 → 하
"""


def evaluate_resume_kpis(resume_text: str) -> Dict[int, int]:
    """
    이력서 텍스트를 LLM이 직접 평가하여 프론트엔드 KPI별 점수 산출.
    
    Few-shot Learning 방식으로 예시를 제공하고,
    LLM이 동일한 기준으로 새 이력서를 평가.
    
    Args:
        resume_text: 이력서/경력 텍스트
    
    Returns:
        {kpi_id: 점수} (점수는 40~90 범위의 정수)
    """
    client = OpenAI(api_key=settings.OPENAI_API_KEY)
    
    system_prompt = f"""너는 프론트엔드 개발자 역량 평가 전문가다.
주어진 이력서/경력 텍스트를 읽고, 10개 KPI에 대해 점수를 매긴다.

{KPI_DEFINITIONS}

{FEW_SHOT_EXAMPLES}

## 출력 형식
반드시 JSON 형식으로만 응답해. 설명 없이 점수만 출력.
{{"1": 점수, "2": 점수, ..., "10": 점수}}

## 점수 부여 규칙 (중요!)
- 상 수준: 75~90 범위에서 근거 강도에 따라 차등 (예: 강한 상=88, 보통 상=82, 약한 상=76)
- 중 수준: 55~70 범위에서 근거 강도에 따라 차등 (예: 강한 중=68, 보통 중=62, 약한 중=56)
- 하 수준: 40~50 범위에서 근거 강도에 따라 차등 (예: 약간 언급=48, 거의 없음=44, 전무=40)

절대 45, 65, 85로 딱 떨어지게 점수를 매기지 마라. 반드시 범위 내에서 세밀하게 차등을 두어라.
"""

    user_prompt = f"""다음 이력서를 평가해줘:

{resume_text}

JSON 형식으로 10개 KPI 점수를 출력해."""

    try:
        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            temperature=0.3,  # 약간의 변동성 허용
            response_format={"type": "json_object"}
        )
        
        result = response.choices[0].message.content
        scores = json.loads(result)
        
        # KPI ID를 int로 변환하고 범위 제한
        return {
            int(kpi_id): max(40, min(90, int(score))) 
            for kpi_id, score in scores.items()
        }
    
    except Exception as e:
        print(f"LLM 평가 오류: {e}")
        # 오류 시 기본값 반환
        return {i: 45 for i in range(1, 11)}
